module scale::nft {
    use sui::object::{Self,UID,ID};
    use std::string::{Self,String};
    use sui::url::{Self, Url};
    use sui::balance::{Balance};
    use scale::pool::{Self,LSP};
    use scale::market::{Self,Market};
    use sui::coin::{Self, Coin};
    use sui::tx_context::{Self,TxContext};
    use std::vector;
    use sui::transfer;
    use sui::table::{Self,Table};
    use scale::admin::AdminCap;
    use sui::dynamic_field as field;
    use std::option::{Self,Option};
    // use scale_v1::nft;

    const ENameRequired:u64 = 1;
    const EDescriptionRequired:u64 = 2;
    const EUrlRequired:u64 = 3;
    const EInvalidNFTID:u64 = 4;
    /// scale nft
    struct ScaleNFT<phantom P, phantom T> has key ,store {
        id: UID,
        name: String,
	    description: String,
	    url: Url,
        mint_time: u64,
        face_value: Balance<LSP<P,T>>,
        issue_expiration_time: u64,
    }
    /// The scale nft factory stores some token templates and styles
    struct ScaleNFTFactory has key {
        id: UID,
        mould: Table<String,ScaleNFTItem>
    }
    /// The scale nft item
    struct ScaleNFTItem has store {
        name: String,
	    description: String,
	    url: Url,
    }

    /// Asset transfer voucher, used for asset transfer during contract upgrade
    struct MoveToken has store {
        nft_id: ID,
        expiration_time: u64
    }
    /// Generated by the target program upgraded to
    struct UpgradeMoveToken has key,store {
        id: UID,
        move_token: MoveToken,
    }

    fun init(ctx: &mut TxContext){
        transfer::share_object(ScaleNFTFactory{
            id: object::new(ctx),
            mould: table::new<String,ScaleNFTItem>(ctx),
        })
    }

    public fun generate_move_token<P,T>(
        _admin_cap: &mut AdminCap,
        nft: &ScaleNFT<P,T>,
        expiration_time: u64,
        _ctx: &mut TxContext,
    ): MoveToken {
        MoveToken{
            nft_id:object::uid_to_inner(&nft.id),
            expiration_time,
        }
    }
    
    /// Withdraw funds from the current pool and destroy NFT bond certificates
    public fun divestment_inner<P,T>(
        market: &mut Market<P,T>,
        nft: ScaleNFT<P,T>,
        move_token: Option<MoveToken>,
        ctx: &mut TxContext
    ){
        let ScaleNFT<P,T> {
            id,
            name:_,
            description:_,
            url:_,
            mint_time:_,
            face_value,
            issue_expiration_time:_
        } = nft;
        // todo: check the expiration time .....
        if (option::is_some(&move_token)){
            // todo: Exempt from liquidated damages and give certain rewards if possible
            let MoveToken {nft_id,expiration_time:_} = option::destroy_some(move_token);
            assert!(object::uid_to_inner(&id) == nft_id, EInvalidNFTID);
        }else{            
            option::destroy_none(move_token);
        };
        transfer::transfer(pool::remove_liquidity(market::get_mut_pool(market),face_value,ctx),tx_context::sender(ctx));
        object::delete(id);
    }
    /// Project side add NFT style
    public entry fun add_factory_mould(
        _admin_cap:&mut AdminCap,
        factory: &mut ScaleNFTFactory,
        name: vector<u8>,
        description: vector<u8>,
        url: vector<u8>,
        _ctx: &mut TxContext
    ) {
        assert!(!vector::is_empty(&name), ENameRequired);
        assert!(!vector::is_empty(&description), EDescriptionRequired);
        assert!(!vector::is_empty(&url), EUrlRequired);
        let name = string::utf8(name);
        table::add(&mut factory.mould,name,ScaleNFTItem{
            name,
            description: string::utf8(description),
            url: url::new_unsafe_from_bytes(url),
        });
    }

    /// Project side delete NFT style
    public entry fun remove_factory_mould(
        _admin_cap:&mut AdminCap,
        factory: &mut ScaleNFTFactory,
        name: vector<u8>,
        _ctx: &mut TxContext
    ) {
        assert!(!vector::is_empty(&name), ENameRequired);
        let ScaleNFTItem {name:_,description:_,url:_} = table::remove(&mut factory.mould,string::utf8(name));
    }

    /// Provide current pool funds and obtain NFT bond certificates
    public entry fun investment<P,T>(
        market: &mut Market<P,T>,
        token: Coin<T>,
        factory: &mut ScaleNFTFactory,
        name: vector<u8>,
        ctx: &mut TxContext
    ){
        // assert!(!vector::is_empty(&name), ENameRequired);
        let mould = table::borrow(&factory.mould,string::utf8(name));
        let lsp = pool::add_liquidity(market::get_mut_pool(market),token,ctx);
        let uid = object::new(ctx);
        let id = object::uid_to_inner(&uid);

        // Index all existing NFTs for interest distribution
        field::add(&mut factory.id,id,true);
        transfer::transfer(ScaleNFT<P,T> {
            id: uid,
            name: mould.name,
            description: mould.description,
            url: mould.url,
            mint_time: 0,
            face_value: coin::into_balance(lsp),
            issue_expiration_time: 0,
        },tx_context::sender(ctx));
    }
    /// Normal withdrawal of investment
    public entry fun divestment<P,T>(
        market: &mut Market<P,T>,
        nft: ScaleNFT<P,T>,
        ctx: &mut TxContext
    ){
        divestment_inner(market,nft,option::none(),ctx);
    }
    /// Generate transfer vouchers for NFT, transfer funds to new contracts when upgrading contracts, 
    /// and there will be no liquidated damages
    /// run in v2
    public entry fun generate_upgrade_move_token<P,T>(
        admin_cap: &mut AdminCap,
        nft: &ScaleNFT<P,T>,
        expiration_time: u64,
        addr: address,
        ctx: &mut TxContext,
    ) {
        transfer::transfer(UpgradeMoveToken{
            id: object::new(ctx),
            move_token: generate_move_token(admin_cap,nft,expiration_time,ctx),
        },addr);
    }

    /// This may happen during version upgrade, and no penalty will be incurred
    /// run in v2
    public entry fun divestment_by_upgrade<P,T>(
        market: &mut Market<P,T>,
        nft: ScaleNFT<P,T>,
        move_token: UpgradeMoveToken,
        ctx: &mut TxContext
    ){
        let UpgradeMoveToken {id,move_token} = move_token;
        divestment_inner(market,nft,option::some(move_token),ctx);
        object::delete(id);
    }
}